<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RIGUZ Lee</title>
  
  <subtitle>Riguz Lee | Not only a programmer</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://riguz.com/"/>
  <updated>2020-04-07T09:31:20.500Z</updated>
  <id>https://riguz.com/</id>
  
  <author>
    <name>Riguz Lee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用Eclipse-CDT构建CMake项目</title>
    <link href="https://riguz.com/it/c/eclipse_cdt/"/>
    <id>https://riguz.com/it/c/eclipse_cdt/</id>
    <published>2020-04-08T00:00:00.000Z</published>
    <updated>2020-04-07T09:31:20.500Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;之前写过一篇文章&lt;a href=&quot;../visual_studio_code_cpp_ide&quot;&gt;Visual Studio Code for C++ development on MacOS&lt;/a&gt;,
        
      
    
    </summary>
    
    
      <category term="Programing" scheme="https://riguz.com/categories/Programing/"/>
    
      <category term="C++" scheme="https://riguz.com/categories/Programing/C/"/>
    
    
      <category term="Eclipse" scheme="https://riguz.com/tags/Eclipse/"/>
    
      <category term="CMake" scheme="https://riguz.com/tags/CMake/"/>
    
  </entry>
  
  <entry>
    <title>阅读笔记：ConcurrentHashMap</title>
    <link href="https://riguz.com/it/java/read_concurrent_hashmap/"/>
    <id>https://riguz.com/it/java/read_concurrent_hashmap/</id>
    <published>2020-03-19T00:00:00.000Z</published>
    <updated>2020-04-07T09:31:20.500Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;我们知道HashMap不是Thread-safe的，而HashTable内部采取了同步操作，是线程安全的。然而有趣的是你去看HashTable的文档，它会建议你：如果不要Thread-Safe你就用HashMap吧，否则你用ConcurrentHashMap好了。&lt;/p&gt;
&lt;p&gt;一般如果对线程安全有要求，我们有如下的一些选择：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ConcurrentHashMap&lt;/li&gt;
&lt;li&gt;Hashtable&lt;/li&gt;
&lt;li&gt;Collections.synchronizedMap&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Programing" scheme="https://riguz.com/categories/Programing/"/>
    
      <category term="Java" scheme="https://riguz.com/categories/Programing/Java/"/>
    
    
      <category term="JDK1.8" scheme="https://riguz.com/tags/JDK1-8/"/>
    
  </entry>
  
  <entry>
    <title>阅读笔记：HashMap</title>
    <link href="https://riguz.com/it/java/read_hashmap/"/>
    <id>https://riguz.com/it/java/read_hashmap/</id>
    <published>2020-03-18T00:00:00.000Z</published>
    <updated>2020-04-07T09:31:20.500Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;HashMap可以算是最常用的数据结构了，而它的实现没想到还挺有学问在里面。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programing" scheme="https://riguz.com/categories/Programing/"/>
    
      <category term="Java" scheme="https://riguz.com/categories/Programing/Java/"/>
    
    
      <category term="JDK1.8" scheme="https://riguz.com/tags/JDK1-8/"/>
    
  </entry>
  
  <entry>
    <title>Redis Memory limit and eviction policy configuration</title>
    <link href="https://riguz.com/it/cache/redis_lru/"/>
    <id>https://riguz.com/it/cache/redis_lru/</id>
    <published>2020-03-10T00:00:00.000Z</published>
    <updated>2020-04-07T09:31:20.500Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;By default, the redis running inside docker has no limitation about memory however generally the container has. Thus if no further configuation of eviction or memory limit is set in redis, you may possibly get some error like Out-of-memory if you keep adding new keys to redis.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programing" scheme="https://riguz.com/categories/Programing/"/>
    
      <category term="Cache" scheme="https://riguz.com/categories/Programing/Cache/"/>
    
    
      <category term="Redis" scheme="https://riguz.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>搭建Openshift本地环境</title>
    <link href="https://riguz.com/it/devops/install_local_openshift/"/>
    <id>https://riguz.com/it/devops/install_local_openshift/</id>
    <published>2020-03-09T00:00:00.000Z</published>
    <updated>2020-04-07T09:31:20.500Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;OpenShift是红帽基于Docker和Kubernetes的云开发平台即服务（PaaS）。而&lt;a href=&quot;https://www.okd.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OKD(The Origin Community Distribution of Kubernetes )&lt;/a&gt;即Openshift的开源版本。在本机上搭建一套完整的Openshift环境较为麻烦，有以下几种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Running in a Container&lt;/li&gt;
&lt;li&gt;Run the All-In-One VM with Minishift&lt;/li&gt;
&lt;li&gt;使用Virtualbox构建Openshift集群&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Programing" scheme="https://riguz.com/categories/Programing/"/>
    
      <category term="Docker" scheme="https://riguz.com/categories/Programing/Docker/"/>
    
    
      <category term="Docker" scheme="https://riguz.com/tags/Docker/"/>
    
      <category term="OpenShift" scheme="https://riguz.com/tags/OpenShift/"/>
    
      <category term="Virtualbox" scheme="https://riguz.com/tags/Virtualbox/"/>
    
  </entry>
  
  <entry>
    <title>Burrows-Wheeler变换(Burrows–Wheeler Transform)</title>
    <link href="https://riguz.com/it/algorithm/about_bwt/"/>
    <id>https://riguz.com/it/algorithm/about_bwt/</id>
    <published>2020-03-04T00:00:00.000Z</published>
    <updated>2020-04-07T09:31:20.500Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;最近听一个医学专业的同学提到了在进行基因分析中用到BWT算法，觉得挺有意思的，正巧赶上这次疫情在家，于是想研究一下这个算法。这个算法的核心思想在于，调整原来的字符串中字符的顺序（而不改变其长度及内容）从而更多的将重复的字符排列到一起，这样有助于其他的压缩算法获得更高的压缩比。这个算法在基因分析中大有用处也就顺理成章了，想想DNA的双链表示大概都是G-T-A-C会有很多这样的字符，那么运用BWT应该可以有比较好的效果。
    
    </summary>
    
    
      <category term="Programing" scheme="https://riguz.com/categories/Programing/"/>
    
      <category term="Algorithm" scheme="https://riguz.com/categories/Programing/Algorithm/"/>
    
    
      <category term="BWT" scheme="https://riguz.com/tags/BWT/"/>
    
  </entry>
  
  <entry>
    <title>LaTeX(3)：使用TikZ绘制图形</title>
    <link href="https://riguz.com/tex/latex_tikz/"/>
    <id>https://riguz.com/tex/latex_tikz/</id>
    <published>2020-02-09T00:00:00.000Z</published>
    <updated>2020-04-07T09:31:20.504Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.ctan.org/pkg/pgf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PGF&lt;/a&gt;是一个用来进行图形绘制的（底层）包，TikZ是利用这个包实现的用户友好的接口。所以通常在LaTeX中会用TikZ来进行矢量图形的绘制。&lt;/p&gt;
    
    </summary>
    
    
      <category term="TeX" scheme="https://riguz.com/categories/TeX/"/>
    
    
      <category term="LaTeX" scheme="https://riguz.com/tags/LaTeX/"/>
    
      <category term="TikZ" scheme="https://riguz.com/tags/TikZ/"/>
    
  </entry>
  
  <entry>
    <title>LaTeX(2)：插入图片</title>
    <link href="https://riguz.com/tex/latex_images/"/>
    <id>https://riguz.com/tex/latex_images/</id>
    <published>2020-02-08T00:00:00.000Z</published>
    <updated>2020-04-07T09:31:20.504Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在LaTeX中插入图片有些类似于Markdown中的方式。
    
    </summary>
    
    
      <category term="TeX" scheme="https://riguz.com/categories/TeX/"/>
    
    
      <category term="LaTeX" scheme="https://riguz.com/tags/LaTeX/"/>
    
  </entry>
  
  <entry>
    <title>LaTeX(1)：章节和段落</title>
    <link href="https://riguz.com/tex/latex_sections/"/>
    <id>https://riguz.com/tex/latex_sections/</id>
    <published>2020-02-07T00:00:00.000Z</published>
    <updated>2020-04-07T09:31:20.504Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;LaTeX适用于学术论文等的写作，在这类文章中一个很重要的部分就是段落和章节了。回想起当年使用Word写作的时候调整标题是何等的痛苦，那么在LaTeX中是怎样设置段落和章节的呢？
    
    </summary>
    
    
      <category term="TeX" scheme="https://riguz.com/categories/TeX/"/>
    
    
      <category term="LaTeX" scheme="https://riguz.com/tags/LaTeX/"/>
    
  </entry>
  
  <entry>
    <title>Mac上的LaTeX环境搭建</title>
    <link href="https://riguz.com/tex/latex_environment/"/>
    <id>https://riguz.com/tex/latex_environment/</id>
    <published>2020-02-06T00:00:00.000Z</published>
    <updated>2020-04-07T09:31:20.504Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;一直希望能够自如的使用TeX来进行写作，但学习曲线还是比较高的，可惜断断续续一直没有能够入门。趁着这段时间疫情严重，待在家里又不想搞学习，那不如来重头开始学习一下吧。
    
    </summary>
    
    
      <category term="TeX" scheme="https://riguz.com/categories/TeX/"/>
    
    
      <category term="LaTeX" scheme="https://riguz.com/tags/LaTeX/"/>
    
  </entry>
  
  <entry>
    <title>调试JDK源码</title>
    <link href="https://riguz.com/it/java/debug_jdk_source/"/>
    <id>https://riguz.com/it/java/debug_jdk_source/</id>
    <published>2020-01-25T00:00:00.000Z</published>
    <updated>2020-04-07T09:31:20.500Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;最近想要直接调试下JDK的源码却发现有些变量不能显示，像这样：&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;/images/Intellij-no-debuginfo.png&quot; alt=&quot;&quot; /&gt;&lt;figcaption&gt;IntelliJ&lt;/figcaption&gt;
&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Programing" scheme="https://riguz.com/categories/Programing/"/>
    
      <category term="Java" scheme="https://riguz.com/categories/Programing/Java/"/>
    
    
      <category term="JDK1.8" scheme="https://riguz.com/tags/JDK1-8/"/>
    
  </entry>
  
  <entry>
    <title>浅析Java中的InvokeDynamic</title>
    <link href="https://riguz.com/it/java/java_invokedynamic/"/>
    <id>https://riguz.com/it/java/java_invokedynamic/</id>
    <published>2019-12-24T00:00:00.000Z</published>
    <updated>2020-04-07T09:31:20.500Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Java语言在被编译成class文件后，在class文件中，有专门的一个&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.4&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;“常量池”(Constant Pool)&lt;/a&gt;区域来存储一些运行所需要的常量，包括一些写死的变量（比如定义一个字符串&lt;code&gt;String str = &quot;Hello world&quot;&lt;/code&gt;以及一些符号，例如类和方法的的名称等）。在JVM(se7)规范中，有以下这些类型的常量：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb1&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span id=&quot;cb1-1&quot;&gt;&lt;a href=&quot;#cb1-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;ex&quot;&gt;CONSTANT_Class&lt;/span&gt;                           CONSTANT_Long            &lt;/span&gt;
&lt;span id=&quot;cb1-2&quot;&gt;&lt;a href=&quot;#cb1-2&quot;&gt;&lt;/a&gt;&lt;span class=&quot;ex&quot;&gt;CONSTANT_Fieldref&lt;/span&gt;                        CONSTANT_Double          &lt;/span&gt;
&lt;span id=&quot;cb1-3&quot;&gt;&lt;a href=&quot;#cb1-3&quot;&gt;&lt;/a&gt;&lt;span class=&quot;ex&quot;&gt;CONSTANT_Methodref&lt;/span&gt;                       CONSTANT_NameAndType     &lt;/span&gt;
&lt;span id=&quot;cb1-4&quot;&gt;&lt;a href=&quot;#cb1-4&quot;&gt;&lt;/a&gt;&lt;span class=&quot;ex&quot;&gt;CONSTANT_InterfaceMethodref&lt;/span&gt;              CONSTANT_Utf8            &lt;/span&gt;
&lt;span id=&quot;cb1-5&quot;&gt;&lt;a href=&quot;#cb1-5&quot;&gt;&lt;/a&gt;&lt;span class=&quot;ex&quot;&gt;CONSTANT_String&lt;/span&gt;                          CONSTANT_MethodHandle    &lt;/span&gt;
&lt;span id=&quot;cb1-6&quot;&gt;&lt;a href=&quot;#cb1-6&quot;&gt;&lt;/a&gt;&lt;span class=&quot;ex&quot;&gt;CONSTANT_Integer&lt;/span&gt;                         CONSTANT_MethodType      &lt;/span&gt;
&lt;span id=&quot;cb1-7&quot;&gt;&lt;a href=&quot;#cb1-7&quot;&gt;&lt;/a&gt;&lt;span class=&quot;ex&quot;&gt;CONSTANT_Float&lt;/span&gt;                           CONSTANT_InvokeDynamic       &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;大部分我们顾名思义，都可以知道是大概是干啥的，比如字符串啊，数字啊，方法名称之类的；但是可以注意到最后面一个是称之为&lt;code&gt;CONSTANT_InvokeDynamic&lt;/code&gt;的常量，这个就有点陌生了。那么，这是一个什么样的常量？什么情况下会出现这个呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programing" scheme="https://riguz.com/categories/Programing/"/>
    
      <category term="Java" scheme="https://riguz.com/categories/Programing/Java/"/>
    
    
      <category term="JVM" scheme="https://riguz.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>使用Vagrant来管理Virtualbox</title>
    <link href="https://riguz.com/it/devops/introduction_to_vagrant/"/>
    <id>https://riguz.com/it/devops/introduction_to_vagrant/</id>
    <published>2019-12-13T00:00:00.000Z</published>
    <updated>2020-04-07T09:31:20.500Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;一直以来我用Virtualbox都是手动创建虚拟机，然后安装操作系统，虽然这个过程本身并不复杂但是也要重复操作和花费时间。通过Vagrant可以像使用Docker一样，编写脚本来管理虚拟机的配置，还可以通过公共的镜像仓库来获取一些别人已经构建好了的镜像。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programing" scheme="https://riguz.com/categories/Programing/"/>
    
      <category term="Docker" scheme="https://riguz.com/categories/Programing/Docker/"/>
    
    
      <category term="Virtualbox" scheme="https://riguz.com/tags/Virtualbox/"/>
    
      <category term="Vagrant" scheme="https://riguz.com/tags/Vagrant/"/>
    
  </entry>
  
  <entry>
    <title>Flutter性能优化实践</title>
    <link href="https://riguz.com/it/mobile/flutter_isolate/"/>
    <id>https://riguz.com/it/mobile/flutter_isolate/</id>
    <published>2019-11-20T00:00:00.000Z</published>
    <updated>2020-04-07T09:31:20.500Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;我的加密软件有一个登录页面，需要用户输入主密码然后验证密码之后才能进入。因为密码转换(Key transform)过程中用到了Argon2算法，而这个算法没有原生的dart实现，所以必须要通过插件的形式来完成，为此我还专门做了一个插件&lt;a href=&quot;https://pub.dev/packages/encryptions&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;encryptions&lt;/a&gt;。调用插件得到秘钥这个过程大概要花个1~4秒钟，最近在安卓真机上测试发现，这个过程中我的进度条竟然出现了卡顿，也就是说本来应该转圈圈的，结果一开始就卡住不动了，那我还需要这个加载动画干嘛呢？为此研究了一番，如何来解决这个问题。
    
    </summary>
    
    
      <category term="Programing" scheme="https://riguz.com/categories/Programing/"/>
    
      <category term="Android" scheme="https://riguz.com/categories/Programing/Android/"/>
    
    
      <category term="Flutter" scheme="https://riguz.com/tags/Flutter/"/>
    
      <category term="Swift" scheme="https://riguz.com/tags/Swift/"/>
    
      <category term="Thread" scheme="https://riguz.com/tags/Thread/"/>
    
      <category term="Java" scheme="https://riguz.com/tags/Java/"/>
    
      <category term="Dart" scheme="https://riguz.com/tags/Dart/"/>
    
  </entry>
  
  <entry>
    <title>Rust(2) Ownership</title>
    <link href="https://riguz.com/it/rust/rust_lang_2_ownership/"/>
    <id>https://riguz.com/it/rust/rust_lang_2_ownership/</id>
    <published>2019-11-18T00:00:00.000Z</published>
    <updated>2020-04-07T09:31:20.500Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;传统的C语言需要开发人员手动管理内存，而像Java、Go这样的语言是通过垃圾回收机制自动进行内存管理。但通常垃圾回收机制本身较为复杂且需要不定期的进行（也就是说实际当内存不在需要的时候并不一定能得到及时的释放）。而rust语言采取的所有权机制（Ownership）是它区别于其他语言的一个重要特征，它被用来进行高效安全的内存管理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programing" scheme="https://riguz.com/categories/Programing/"/>
    
      <category term="Rust" scheme="https://riguz.com/categories/Programing/Rust/"/>
    
    
  </entry>
  
  <entry>
    <title>Java中的时间</title>
    <link href="https://riguz.com/it/java/java_datetime/"/>
    <id>https://riguz.com/it/java/java_datetime/</id>
    <published>2019-11-07T00:00:00.000Z</published>
    <updated>2020-04-07T09:31:20.500Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;你如果以为，Java中谈到时间仅仅就意味着&lt;code&gt;java.util.Date&lt;/code&gt;那就大错特错了，Java中的时间其实可以说五花八门，Java8发布后又增加了一些新的用来表示日期和时间的类，那么我们在构建应用程序的时候到底应该用哪个类来呢？彼此之间又有什么区别？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programing" scheme="https://riguz.com/categories/Programing/"/>
    
      <category term="Java" scheme="https://riguz.com/categories/Programing/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>理解Java并发(2)：ThreadPoolExecutor解析</title>
    <link href="https://riguz.com/it/java/java_thread_pool_executor/"/>
    <id>https://riguz.com/it/java/java_thread_pool_executor/</id>
    <published>2019-10-31T00:00:00.000Z</published>
    <updated>2020-04-07T09:31:20.500Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;使用多线程技术可以有效的利用CPU时间，在同一个时间内完成更多的任务，但同时值得注意的是，线程创建本身也是有开销的，线程池使得我们可以重复的利用已经存在的线程，从而节省这一部分的开销，提高程序的效率。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programing" scheme="https://riguz.com/categories/Programing/"/>
    
      <category term="Java" scheme="https://riguz.com/categories/Programing/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>理解Java并发(1)：基本机制</title>
    <link href="https://riguz.com/it/java/java_cocurrent_basics/"/>
    <id>https://riguz.com/it/java/java_cocurrent_basics/</id>
    <published>2019-10-28T00:00:00.000Z</published>
    <updated>2020-04-07T09:31:20.500Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;线程是操作系统中进行运算调度的最小单位，它是一个单一顺序的控制流，不论是对于单核还是多核的CPU，都能比较有效的提高程序的吞吐率。在Java中，创建一个线程的唯一方法是创建一个&lt;code&gt;Thread&lt;/code&gt;类的实例，并调用&lt;code&gt;start()&lt;/code&gt;方法以启动该线程。然而当多个线程同时执行时，如何保证线程之间是按照我们期待的方式在运行呢？Java提供了多种机制来保证多个线程之间的交互。
    
    </summary>
    
    
      <category term="Programing" scheme="https://riguz.com/categories/Programing/"/>
    
      <category term="Java" scheme="https://riguz.com/categories/Programing/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Rust(1) 基本语法</title>
    <link href="https://riguz.com/it/rust/rust_lang_1_basic/"/>
    <id>https://riguz.com/it/rust/rust_lang_1_basic/</id>
    <published>2019-10-22T00:00:00.000Z</published>
    <updated>2020-04-07T09:31:20.500Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;使用rust语言编写hello world再容易不过了：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb1&quot;&gt;&lt;pre class=&quot;sourceCode rust&quot;&gt;&lt;code class=&quot;sourceCode rust&quot;&gt;&lt;span id=&quot;cb1-1&quot;&gt;&lt;a href=&quot;#cb1-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;kw&quot;&gt;fn&lt;/span&gt; main() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-2&quot;&gt;&lt;a href=&quot;#cb1-2&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;pp&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;Hello world!&amp;quot;&lt;/span&gt;);&lt;/span&gt;
&lt;span id=&quot;cb1-3&quot;&gt;&lt;a href=&quot;#cb1-3&quot;&gt;&lt;/a&gt;&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后利用rustc编译器编译即可:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb2&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span id=&quot;cb2-1&quot;&gt;&lt;a href=&quot;#cb2-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;ex&quot;&gt;rustc&lt;/span&gt; hell.rs -o hello.out &lt;span class=&quot;kw&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;ex&quot;&gt;./hello.out&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="Programing" scheme="https://riguz.com/categories/Programing/"/>
    
      <category term="Rust" scheme="https://riguz.com/categories/Programing/Rust/"/>
    
    
  </entry>
  
  <entry>
    <title>C++中的NRVO</title>
    <link href="https://riguz.com/it/c/nrvo_in_cplusplus/"/>
    <id>https://riguz.com/it/c/nrvo_in_cplusplus/</id>
    <published>2019-09-25T00:00:00.000Z</published>
    <updated>2020-04-07T09:31:20.500Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;对于C++这种需要精细管理对象的语言来说有时候真是比较复杂，一个看似简单的问题一直在困惑着我：到底可不可以在方法中返回局部变量呢？
    
    </summary>
    
    
      <category term="Programing" scheme="https://riguz.com/categories/Programing/"/>
    
      <category term="C++" scheme="https://riguz.com/categories/Programing/C/"/>
    
    
      <category term="NRVO" scheme="https://riguz.com/tags/NRVO/"/>
    
  </entry>
  
</feed>
